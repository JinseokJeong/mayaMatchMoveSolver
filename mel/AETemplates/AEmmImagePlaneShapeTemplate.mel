//
// Copyright (C) 2022 David Cattermole.
//
// This file is part of mmSolver.
//
// mmSolver is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// mmSolver is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with mmSolver.  If not, see <https://www.gnu.org/licenses/>.
// ---------------------------------------------------------------------
//
// Image plane transform node Template file.
//


source "AEmmNodeTemplateCommon";


global proc int AEassignImageSequenceCallback(
    string $file_attr,
    string $file_name,
    string $file_type)
{
    setAttr $file_attr -type "string" $file_name;
    string $image_plane_shp[];
    tokenize ($file_attr, ".", $image_plane_shp);

    string $image_plane_tfm[] = `listRelatives -parent $image_plane_shp[0]`;

    string $command = "import mmSolver.tools.createimageplane.lib as lib; ";
    $command = $command + "lib.set_image_sequence(";
    $command = $command + "\"" + $image_plane_tfm[0] + "\"";
    $command = $command + ", \"" + $file_name + "\");";

    python($command);

    return true;
}


global proc AEmmImagePlaneShapeBrowser(
    string $cmd,
    string $image_plane_shp)
{
    // TODO: Use the python function
    // 'mmSolver.tools.createimageplane.tool.prompt_user_for_image_sequence()'.
    string$workspace = `workspace -q -fn`;
    setWorkingDirectory $workspace "image" "sourceImages";
    string $open = (uiRes("m_AEimagePlaneTemplate.kOpen"));
    fileBrowser($cmd, $open, "image", 0);
}


global proc AEmmImagePlaneShapeImageSequenceNew(string $file_attr)
{
    setUITemplate -pst attributeEditorTemplate;
    rowLayout -nc 3 textureNameLayout;
    text -label "Image Sequence";
    textField textureNameField;
    symbolButton -image "navButtonBrowse.png" browser;
    setParent ..;
    setUITemplate -ppt;

    AEmmImagePlaneShapeImageSequenceReplace $file_attr;
}


global proc AEmmImagePlaneShapeImageSequenceReplace(string $file_attr)
{
    string $image_plane_shp[];
    tokenize($file_attr, ".", $image_plane_shp);
    if(size($image_plane_shp) < 1) {
        return;
    }

    connectControl -fileName textureNameField $file_attr;

    string $command1 = "AEassignImageSequenceCallback " + $file_attr;
    string $command2 = "AEmmImagePlaneShapeBrowser \"" + $command1 + "\" " + $image_plane_shp[0];

    button -edit -command $command2 browser;
}


global proc AEmmImagePlaneShapeTemplate(string $nodeName)
{
    AEmmNodeShapeTemplateCommonBegin($nodeName);

    editorTemplate -beginLayout "Display" -collapse 0;
    editorTemplate -addControl "visibility";
    // editorTemplate -addControl "visibleToCameraOnly";  // Or "showInCameraOnly"
    editorTemplate -addSeparator;
    editorTemplate -addControl "exposure";
    editorTemplate -addControl "gamma";
    editorTemplate -addControl "colorGain";
    editorTemplate -addControl "alphaGain";
    // editorTemplate -addSeparator;
    // editorTemplate -addControl "colorSpace";  // Might not be possible.
    editorTemplate -endLayout;

    editorTemplate -beginLayout "Image Sequence" -collapse 0;
    editorTemplate
        -callCustom
        "AEmmImagePlaneShapeImageSequenceNew"
        "AEmmImagePlaneShapeImageSequenceReplace"
        "imageSequence";
    // TODO: Add radio button to choose what will connect to the
    // 'imageSequenceFrame' value? Options are:
    //  - Scene Time (time1)
    //  - Animation Curve
    //
    editorTemplate -addControl "imageSequenceFrame";
    editorTemplate -addControl "imageSequenceFirstFrame";
    editorTemplate -addControl "imageSequenceFrameOutput";
    editorTemplate -addSeparator;
    editorTemplate -addControl "imageLoadEnable";
    editorTemplate -addControl "imageUseAlphaChannel";
    editorTemplate -addSeparator;
    editorTemplate -addControl "imageWidth";
    editorTemplate -addControl "imageHeight";
    editorTemplate -addControl "imagePixelAspect";
    editorTemplate -addSeparator;
    editorTemplate -addControl "imageSequenceStartFrame";
    editorTemplate -addControl "imageSequenceEndFrame";
    editorTemplate -endLayout;

    editorTemplate -beginLayout "HUD" -collapse 0;
    editorTemplate -addControl "drawHud";
    editorTemplate -addSeparator;
    editorTemplate -addControl "drawImageResolution";
    editorTemplate -addControl "drawCameraSize";
    // TODO: Add 'hudTextColor' - control the HUD text color.
    editorTemplate -endLayout;

    editorTemplate -beginLayout "Miscellaneous" -collapse 1;
    editorTemplate -addControl "meshResolution";
    editorTemplate -addControl "imageDefaultColor";  // Cannot be textured.
    editorTemplate -endLayout;

    editorTemplate -beginLayout "Nodes" -collapse 1;
    editorTemplate -addControl "shaderNode";
    editorTemplate -addControl "shaderFileNode";
    editorTemplate -addControl "geometryNode";
    editorTemplate -addControl "imagePlaneShapeNode";
    editorTemplate -endLayout;

    editorTemplate -suppress "imageSequencePadding";
    editorTemplate -suppress "cameraWidthInch";
    editorTemplate -suppress "cameraHeightInch";
    editorTemplate -suppress "lensHashCurrent";
    editorTemplate -suppress "lensHashPrevious";

    AEmmNodeShapeTemplateCommonEnd($nodeName);
}
